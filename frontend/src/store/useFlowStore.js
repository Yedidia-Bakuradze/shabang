import { create } from 'zustand';
import {
  applyNodeChanges,
  applyEdgeChanges,
  addEdge
} from 'reactflow';
import { calculateAutoLayout } from '../utils/autoLayout';

const useFlowStore = create((set, get) => ({
  nodes: [],
  edges: [],
  projectId: null,
  hasUnsavedChanges: false,
  selectedNodeId: null,
  
  // DSD View Mode State
  viewMode: 'erd', // 'erd' | 'dsd'
  dsdData: null,   // DSD tables from backend
  dsdNodes: [],    // React Flow nodes for DSD view
  dsdEdges: [],    // React Flow edges for DSD view (FK relationships)

  setViewMode: (mode) => {
    // When switching to DSD mode, only show existing DSD data
    // DSD should only be generated by the backend during save operations
    set({ viewMode: mode });
  },

  setDSDData: (dsd) => {
    if (!dsd || !dsd.tables) {
      set({ dsdData: null, dsdNodes: [], dsdEdges: [] });
      return;
    }
    
    // Generate React Flow nodes and edges from DSD data
    const { nodes: dsdNodes, edges: dsdEdges } = get().generateDSDNodesAndEdges(dsd);
    set({ dsdData: dsd, dsdNodes, dsdEdges });
  },

  generateDSDNodesAndEdges: (dsd) => {
    const nodes = [];
    const edges = [];
    const tablePositions = {};
    
    // Layout constants
    const SPACING_X = 350;
    const SPACING_Y = 300;
    const COLS = 3;
    
    // Create DSD table nodes
    dsd.tables.forEach((table, index) => {
      const row = Math.floor(index / COLS);
      const col = index % COLS;
      const x = 100 + col * SPACING_X;
      const y = 100 + row * SPACING_Y;
      
      tablePositions[table.name] = { x, y };
      
      // Find PK and FK columns
      const pkColumns = new Set();
      const fkColumns = {};
      
      table.constraints?.forEach(constraint => {
        if (constraint.type === 'PRIMARY KEY') {
          constraint.columns?.forEach(col => pkColumns.add(col));
        }
        if (constraint.type === 'FOREIGN KEY') {
          constraint.columns?.forEach((col, idx) => {
            fkColumns[col] = {
              referencedTable: constraint.referenced_table,
              referencedColumn: constraint.referenced_columns?.[idx] || constraint.referenced_columns?.[0]
            };
          });
        }
      });
      
      nodes.push({
        id: `dsd-${table.name}`,
        type: 'dsdTableNode',
        position: { x, y },
        data: {
          tableName: table.name,
          description: table.description,
          columns: table.columns.map(col => ({
            name: col.name,
            type: col.sql_type,
            nullable: col.nullable,
            isPrimaryKey: pkColumns.has(col.name),
            isForeignKey: !!fkColumns[col.name],
            fkReference: fkColumns[col.name]
          })),
          constraints: table.constraints,
          indexes: table.indexes
        }
      });
    });
    
    // Create FK edges - iterate through all tables and their FK constraints
    dsd.tables.forEach(table => {
      const sourceTableName = table.name;
      
      table.constraints?.forEach(constraint => {
        if (constraint.type === 'FOREIGN KEY' && constraint.referenced_table) {
          const targetTableName = constraint.referenced_table;
          const fkColumns = constraint.columns || [];
          const referencedColumns = constraint.referenced_columns || [];
          
          // Check if both tables exist
          const sourceExists = nodes.some(n => n.id === `dsd-${sourceTableName}`);
          const targetExists = nodes.some(n => n.id === `dsd-${targetTableName}`);
          
          if (sourceExists && targetExists) {
            // Create an edge for each FK column (usually just one, but could be composite)
            fkColumns.forEach((fkColumn, idx) => {
              const pkColumn = referencedColumns[idx] || referencedColumns[0] || 'id';
              
              // Theme-aware edge styling
              // Use markerEnd with type to let React Flow handle the arrow
              edges.push({
                id: `dsd-edge-${sourceTableName}-${targetTableName}-${fkColumn}-${idx}`,
                source: `dsd-${sourceTableName}`,
                target: `dsd-${targetTableName}`,
                type: 'smoothstep',
                animated: false,
                style: { 
                  strokeWidth: 2
                },
                className: 'dsd-fk-edge',  // Use CSS class for theme-aware styling
                markerEnd: {
                  type: 'arrowclosed'
                },
                label: `FK: ${fkColumn}`,
                labelStyle: { 
                  fontSize: 11,
                  fontWeight: 600
                },
                labelClassName: 'dsd-fk-label',  // Use CSS class for theme-aware styling
                labelBgClassName: 'dsd-fk-label-bg'
              });
            });
          }
        }
      });
    });
    
    return { nodes, edges };
  },

  setSelectedNodeId: (id) => {
    set({ selectedNodeId: id });
  },

  setProjectId: (id) => {
    set({ projectId: id });
  },

  setEdges: (updateFnOrEdges) => {
    const currentEdges = get().edges;
    const newEdges = typeof updateFnOrEdges === 'function'
      ? updateFnOrEdges(currentEdges)
      : updateFnOrEdges;
    set({ edges: newEdges, hasUnsavedChanges: true });
  },

  loadProjectData: (entities) => {
    // Project Isolation: Always clear ALL state first, including DSD data
    // This ensures no data carries over from previous projects

    if (entities && entities.nodes && entities.edges) {
      // Loading an existing project with data
      set({
        nodes: entities.nodes,
        edges: entities.edges,
        hasUnsavedChanges: false,
        selectedNodeId: null,
        // Clear DSD state - will be regenerated from backend data or on-demand
        viewMode: 'erd'  // Always start in ERD mode
      });
    } else {
      // Empty/new project - clear the canvas completely
      set({
        nodes: [],
        edges: [],
        hasUnsavedChanges: false,
        selectedNodeId: null,
        // Clear DSD state
        dsdData: null,
        dsdNodes: [],
        dsdEdges: [],
        viewMode: 'erd'
      });
    }
  },

  getCanvasData: () => {
    return {
      nodes: get().nodes,
      edges: get().edges
    };
  },

  markAsSaved: () => {
    set({ hasUnsavedChanges: false });
  },

  onNodesChange: (changes) => {
    const currentNodes = get().nodes;
    const viewMode = get().viewMode;
    const dsdNodes = get().dsdNodes;
    
    // If we're in DSD mode, handle position changes for DSD nodes
    if (viewMode === 'dsd') {
      const updatedDsdNodes = applyNodeChanges(changes, dsdNodes);
      
      // Save position updates back to ERD entities for persistence
      changes.forEach(change => {
        if (change.type === 'position' && change.position && !change.dragging) {
          const dsdNode = dsdNodes.find(n => n.id === change.id);
          if (dsdNode && dsdNode.data.tableName) {
            // Find corresponding ERD entity and save DSD position
            const tableName = dsdNode.data.tableName;
            const erdEntity = currentNodes.find(n => 
              n.type === 'entityNode' && n.data.label === tableName
            );
            
            if (erdEntity) {
              const updatedNodes = currentNodes.map(n => 
                n.id === erdEntity.id 
                  ? { ...n, data: { ...n.data, dsdPosition: change.position } }
                  : n
              );
              set({ nodes: updatedNodes, hasUnsavedChanges: true });
            }
          }
        }
      });
      
      set({ dsdNodes: updatedDsdNodes });
      return;
    }

    // Check for deletions to sync with Data
    changes.forEach(change => {
      if (change.type === 'remove') {
        const removedNode = currentNodes.find(n => n.id === change.id);

        if (removedNode && removedNode.type === 'attributeNode') {
          // Sync Entity Deletion
          const connectedEntity = currentNodes.find(n =>
            n.type === 'entityNode' &&
            n.data.attributes &&
            n.data.attributes.some(attr => attr.id === removedNode.id)
          );
          // Sync Relationship Deletion
          const connectedRel = currentNodes.find(n =>
            n.type === 'relationshipNode' &&
            n.data.attributes &&
            n.data.attributes.some(attr => attr.id === removedNode.id)
          );
          // Actual cleanup happens in post-processing map below
        }
      }
    });

    const newNodes = applyNodeChanges(changes, currentNodes);

    // POST-PROCESSING: Ensure data consistency after deletion
    const activeNodeIds = new Set(newNodes.map(n => n.id));

    const syncedNodes = newNodes.map(node => {
      // Clean Entities
      if (node.type === 'entityNode' && node.data.attributes) {
        const validAttributes = node.data.attributes.filter(attr => activeNodeIds.has(attr.id));
        if (validAttributes.length !== node.data.attributes.length) {
          return { ...node, data: { ...node.data, attributes: validAttributes } };
        }
      }
      // Clean Relationships
      if (node.type === 'relationshipNode' && node.data.attributes) {
        const validAttributes = node.data.attributes.filter(attr => activeNodeIds.has(attr.id));
        if (validAttributes.length !== node.data.attributes.length) {
          return { ...node, data: { ...node.data, attributes: validAttributes } };
        }
      }
      return node;
    });

    set({
      nodes: syncedNodes,
      hasUnsavedChanges: true
    });
  },

  onEdgesChange: (changes) => {
    const currentEdges = get().edges;
    const currentNodes = get().nodes;
    let updatedNodes = [...currentNodes];

    changes.forEach(change => {
      if (change.type === 'remove') {
        const removedEdge = currentEdges.find(e => e.id === change.id);

        if (removedEdge) {
          const sourceNode = currentNodes.find(n => n.id === removedEdge.source);
          const targetNode = currentNodes.find(n => n.id === removedEdge.target);

          if (sourceNode && targetNode) {
            // CASE 1: Entity <-> Attribute Edge Deleted
            if (
              (sourceNode.type === 'entityNode' && targetNode.type === 'attributeNode') ||
              (sourceNode.type === 'attributeNode' && targetNode.type === 'entityNode')
            ) {
              const entityNode = sourceNode.type === 'entityNode' ? sourceNode : targetNode;
              const attributeId = sourceNode.type === 'attributeNode' ? sourceNode.id : targetNode.id;
              updatedNodes = updatedNodes.map(node => node.id === entityNode.id ? {
                ...node, data: { ...node.data, attributes: (node.data.attributes || []).filter(attr => attr.id !== attributeId) }
              } : node);
            }

            // CASE 2: Relationship <-> Attribute Edge Deleted
            else if (
              (sourceNode.type === 'relationshipNode' && targetNode.type === 'attributeNode') ||
              (sourceNode.type === 'attributeNode' && targetNode.type === 'relationshipNode')
            ) {
              const relNode = sourceNode.type === 'relationshipNode' ? sourceNode : targetNode;
              const attributeId = sourceNode.type === 'attributeNode' ? sourceNode.id : targetNode.id;
              updatedNodes = updatedNodes.map(node => node.id === relNode.id ? {
                ...node, data: { ...node.data, attributes: (node.data.attributes || []).filter(attr => attr.id !== attributeId) }
              } : node);
            }

            // CASE 3: Entity <-> Relationship Edge Deleted
            else if (
              (sourceNode.type === 'entityNode' && targetNode.type === 'relationshipNode') ||
              (sourceNode.type === 'relationshipNode' && targetNode.type === 'entityNode')
            ) {
              const relNode = sourceNode.type === 'relationshipNode' ? sourceNode : targetNode;
              const entityId = sourceNode.type === 'entityNode' ? sourceNode.id : targetNode.id;
              updatedNodes = updatedNodes.map(node => node.id === relNode.id ? {
                ...node, data: { ...node.data, entityConnections: (node.data.entityConnections || []).filter(id => id !== entityId) }
              } : node);
            }
          }
        }
      }
    });

    set({
      edges: applyEdgeChanges(changes, currentEdges),
      nodes: updatedNodes,
      hasUnsavedChanges: true
    });
  },

  onConnect: (connection) => {
    const { source, target, sourceHandle, targetHandle } = connection;
    const nodes = get().nodes;
    const edges = get().edges;
    const sourceNode = nodes.find(n => n.id === source);
    const targetNode = nodes.find(n => n.id === target);

    if (!sourceNode || !targetNode) return;

    // === CONNECTION RULES ===
    // 1. Attributes MUST connect via bottom handle of Entity
    // 2. Relationships MUST connect via top/left/right handles
    // 3. Attributes can only have ONE parent (single-parent rule)

    if (sourceNode.type === 'entityNode' && targetNode.type === 'entityNode') {
      // Smart ERD Insert - Create Relationship Diamond between entities
      const midX = (sourceNode.position.x + targetNode.position.x) / 2;
      const midY = (sourceNode.position.y + targetNode.position.y) / 2;
      const relationshipId = `rel-${Date.now()}`;
      const relationshipNode = { 
        id: relationshipId, 
        type: 'relationshipNode', 
        position: { x: midX, y: midY }, 
        data: { 
          label: 'Relationship', 
          relationshipType: '1:N',
          entityConnections: [source, target], 
          attributes: [] 
        } 
      };
      const edge1 = { 
        id: `edge-${source}-${relationshipId}`, 
        source: source, 
        sourceHandle: 'handle-right',
        target: relationshipId, 
        type: 'erdEdge', 
        label: '1', 
        data: { edgeType: 'relationship', sourceCardinality: 'ONE', targetCardinality: 'ONE' } 
      };
      const edge2 = { 
        id: `edge-${relationshipId}-${target}`, 
        source: relationshipId, 
        target: target,
        targetHandle: 'handle-left', 
        type: 'erdEdge', 
        label: 'N', 
        data: { edgeType: 'relationship', sourceCardinality: 'MANY', targetCardinality: 'ONE' } 
      };
      set({ nodes: [...nodes, relationshipNode], edges: [...edges, edge1, edge2], hasUnsavedChanges: true });
    }
    else {
      let edgeData = {};
      let label = null;
      let newNodes = [...nodes];
      let newEdges = [...edges];
      let finalSourceHandle = sourceHandle;
      let finalTargetHandle = targetHandle;

      // Entity <-> Attribute
      if ((sourceNode.type === 'entityNode' && targetNode.type === 'attributeNode') || (sourceNode.type === 'attributeNode' && targetNode.type === 'entityNode')) {
        edgeData = { edgeType: 'attribute' };
        const entityNode = sourceNode.type === 'entityNode' ? sourceNode : targetNode;
        const attributeNode = sourceNode.type === 'attributeNode' ? sourceNode : targetNode;
        
        // === FORCE BOTTOM HANDLE FOR ATTRIBUTES ===
        // Override the connection handles to always use the bottom handle for entity-attribute connections
        if (sourceNode.type === 'entityNode') {
          finalSourceHandle = 'handle-attributes';
        } else {
          finalTargetHandle = 'handle-attributes';
        }
        
        // === SINGLE-PARENT RULE (STRICT ENFORCEMENT) ===
        // An attribute can only belong to ONE entity at a time
        // Check both data.attributes AND edges for existing connections
        
        // Method 1: Check data.attributes on all entities
        const existingParentEntity = newNodes.find(n => 
          n.type === 'entityNode' && 
          n.id !== entityNode.id &&
          n.data.attributes?.some(attr => attr.id === attributeNode.id)
        );
        
        if (existingParentEntity) {
          // Remove attribute from previous parent's data
          newNodes = newNodes.map(n => {
            if (n.id === existingParentEntity.id) {
              return {
                ...n,
                data: {
                  ...n.data,
                  attributes: n.data.attributes.filter(attr => attr.id !== attributeNode.id)
                }
              };
            }
            return n;
          });
        }
        
        // Method 2: Remove ALL existing edges connecting this attribute to ANY entity
        // This ensures no visual multi-parenting even if data is inconsistent
        newEdges = newEdges.filter(e => {
          const isAttrEdge = e.data?.edgeType === 'attribute';
          const involvesThisAttr = e.source === attributeNode.id || e.target === attributeNode.id;
          const involvesOtherEntity = (e.source !== entityNode.id && e.target !== entityNode.id);
          
          // Keep edge if: not an attribute edge, or doesn't involve this attribute, 
          // or it's connecting to the NEW entity (we want to keep/create that)
          if (!isAttrEdge) return true;
          if (!involvesThisAttr) return true;
          if (!involvesOtherEntity) return true; // Keep if it's already connected to new entity
          
          // Remove: attribute edge to a DIFFERENT entity
          const otherNodeId = e.source === attributeNode.id ? e.target : e.source;
          const otherNode = newNodes.find(n => n.id === otherNodeId);
          if (otherNode?.type === 'entityNode') {
            // Also clean up that entity's data.attributes
            newNodes = newNodes.map(n => {
              if (n.id === otherNodeId && n.data.attributes) {
                return {
                  ...n,
                  data: {
                    ...n.data,
                    attributes: n.data.attributes.filter(attr => attr.id !== attributeNode.id)
                  }
                };
              }
              return n;
            });
            return false; // Remove this edge
          }
          return true;
        });
        
        // Add attribute to new parent entity
        const currentAttributes = entityNode.data.attributes || [];
        if (!currentAttributes.some(attr => attr.id === attributeNode.id)) {
          const updatedEntityNode = { 
            ...entityNode, 
            data: { 
              ...entityNode.data, 
              attributes: [
                ...currentAttributes, 
                { 
                  id: attributeNode.id, 
                  name: attributeNode.data.label, 
                  isKey: attributeNode.data.isKey || false,
                  dataType: attributeNode.data.dataType || 'VARCHAR',
                  allowNull: true,
                  isUnique: false
                }
              ] 
            } 
          };
          newNodes = newNodes.map(n => n.id === entityNode.id ? updatedEntityNode : n);
        }
      }
      // Relationship <-> Attribute
      else if ((sourceNode.type === 'relationshipNode' && targetNode.type === 'attributeNode') || (sourceNode.type === 'attributeNode' && targetNode.type === 'relationshipNode')) {
        edgeData = { edgeType: 'attribute' };
        const relNode = sourceNode.type === 'relationshipNode' ? sourceNode : targetNode;
        const attributeNode = sourceNode.type === 'attributeNode' ? sourceNode : targetNode;
        const currentAttributes = relNode.data.attributes || [];
        if (!currentAttributes.some(attr => attr.id === attributeNode.id)) {
          const updatedRelNode = { ...relNode, data: { ...relNode.data, attributes: [...currentAttributes, { id: attributeNode.id, name: attributeNode.data.label, isKey: false }] } };
          newNodes = newNodes.map(n => n.id === relNode.id ? updatedRelNode : n);
        }
      }
      // Attribute <-> Attribute
      else if (sourceNode.type === 'attributeNode' && targetNode.type === 'attributeNode') {
        edgeData = { edgeType: 'attribute' };
      }
      // Entity <-> Relationship
      else if ((sourceNode.type === 'entityNode' && targetNode.type === 'relationshipNode') || (sourceNode.type === 'relationshipNode' && targetNode.type === 'entityNode')) {
        edgeData = { edgeType: 'relationship', sourceCardinality: 'MANY', targetCardinality: 'ONE' };
        label = 'N';
        const relNode = sourceNode.type === 'relationshipNode' ? sourceNode : targetNode;
        const entityId = sourceNode.type === 'entityNode' ? sourceNode.id : targetNode.id;
        if (!relNode.data.entityConnections?.includes(entityId)) {
          const updatedRelNode = { ...relNode, data: { ...relNode.data, entityConnections: [...(relNode.data.entityConnections || []), entityId] } };
          newNodes = newNodes.map(n => n.id === relNode.id ? updatedRelNode : n);
        }
      }

      set({ nodes: newNodes, edges: addEdge({ ...connection, sourceHandle: finalSourceHandle, targetHandle: finalTargetHandle, type: 'erdEdge', label: label, data: edgeData }, newEdges), hasUnsavedChanges: true });
    }
  },

  addNode: (nodeType = 'entityNode') => {
    const baseNode = { id: `node-${Date.now()}`, position: { x: Math.random() * 400 + 100, y: Math.random() * 400 + 100 } };
    let newNode = { ...baseNode, type: nodeType, data: { label: `New_${nodeType}`, attributes: [] } };
    if (nodeType === 'attributeNode') newNode.data = { label: 'New_Attribute', isKey: false };
    if (nodeType === 'relationshipNode') newNode.data = { label: 'New_Relationship', entityConnections: [], attributes: [] };

    set({ nodes: [...get().nodes, newNode], hasUnsavedChanges: true });
  },

  autoLayout: () => {
    const { nodes, edges } = get();
    const layoutedNodes = calculateAutoLayout(nodes, edges);
    set({ nodes: layoutedNodes, hasUnsavedChanges: true });
  },

  updateNodeData: (nodeId, newData) => {
    set({
      nodes: get().nodes.map((node) => node.id === nodeId ? { ...node, data: { ...node.data, ...newData } } : node),
      hasUnsavedChanges: true
    });
  },

  updateNodeLabel: (nodeId, newLabel) => {
    const nodes = get().nodes;
    const targetNode = nodes.find(n => n.id === nodeId);
    let updatedNodes = nodes.map((node) =>
      node.id === nodeId ? { ...node, data: { ...node.data, label: newLabel } } : node
    );

    // Sync label with Parent Data (Entity or Relationship)
    if (targetNode && targetNode.type === 'attributeNode') {
      updatedNodes = updatedNodes.map(node => {
        // Update Entity
        if (node.type === 'entityNode' && node.data.attributes?.some(attr => attr.id === nodeId)) {
          return { ...node, data: { ...node.data, attributes: node.data.attributes.map(attr => attr.id === nodeId ? { ...attr, name: newLabel } : attr) } };
        }
        // Update Relationship
        if (node.type === 'relationshipNode' && node.data.attributes?.some(attr => attr.id === nodeId)) {
          return { ...node, data: { ...node.data, attributes: node.data.attributes.map(attr => attr.id === nodeId ? { ...attr, name: newLabel } : attr) } };
        }
        return node;
      });
    }

    set({ nodes: updatedNodes, hasUnsavedChanges: true });
  },

  // --- ENTITY ATTRIBUTE ACTIONS ---
  connectAttributeToEntity: (entityId, attributeId) => {
    const entity = get().nodes.find(n => n.id === entityId);
    const attribute = get().nodes.find(n => n.id === attributeId);
    if (!entity || !attribute) return;
    if (entity.data.attributes?.some(attr => attr.id === attributeId)) return;
    const newEdge = { id: `edge-${entityId}-${attributeId}`, source: entityId, sourceHandle: 'handle-attributes', target: attributeId, type: 'erdEdge', data: { edgeType: 'attribute' } };
    const updatedAttributes = [...(entity.data.attributes || []), { id: attributeId, name: attribute.data.label, isKey: attribute.data.isKey || false }];
    set({ nodes: get().nodes.map(n => n.id === entityId ? { ...n, data: { ...n.data, attributes: updatedAttributes } } : n), edges: addEdge(newEdge, get().edges), hasUnsavedChanges: true });
  },

  disconnectAttributeFromEntity: (entityId, attributeId) => {
    const entity = get().nodes.find(n => n.id === entityId);
    if (!entity) return;
    set({
      nodes: get().nodes.map(n => n.id === entityId ? { ...n, data: { ...n.data, attributes: n.data.attributes.filter(attr => attr.id !== attributeId) } } : n),
      edges: get().edges.filter(edge => !((edge.source === entityId && edge.target === attributeId) || (edge.source === attributeId && edge.target === entityId))),
      hasUnsavedChanges: true
    });
  },

  addAttributeToEntity: (entityId, attributeData) => {
    const entity = get().nodes.find(n => n.id === entityId);
    if (!entity) return;
    const attributeId = `attr-${Date.now()}`;
    const existingAttributes = entity.data.attributes || [];
    const offsetX = (existingAttributes.length % 3) * 150;
    const offsetY = Math.floor(existingAttributes.length / 3) * 100 + 100;
    const newAttributeNode = { id: attributeId, type: 'attributeNode', position: { x: entity.position.x + offsetX, y: entity.position.y + offsetY }, data: { label: attributeData.name || 'New_Attribute', isKey: attributeData.isKey || false, entityId: entityId } };
    const newEdge = { id: `edge-${entityId}-${attributeId}`, source: entityId, sourceHandle: 'handle-attributes', target: attributeId, type: 'erdEdge', data: { edgeType: 'attribute' } };
    const updatedAttributes = [...existingAttributes, { id: attributeId, name: attributeData.name, isKey: attributeData.isKey }];
    set({ nodes: [...get().nodes.map(n => n.id === entityId ? { ...n, data: { ...n.data, attributes: updatedAttributes } } : n), newAttributeNode], edges: [...get().edges, newEdge], hasUnsavedChanges: true });
  },

  updateEntityAttribute: (entityId, attributeId, attributeData) => {
    const entity = get().nodes.find(n => n.id === entityId);
    if (!entity) return;
    const updatedAttributes = entity.data.attributes.map(attr => attr.id === attributeId ? { ...attr, ...attributeData } : attr);
    const nodes = get().nodes.map(node => {
      if (node.id === entityId) return { ...node, data: { ...node.data, attributes: updatedAttributes } };
      if (node.id === attributeId) {
        let newData = { ...node.data };
        if (attributeData.name) newData.label = attributeData.name;
        if (attributeData.isKey !== undefined) newData.isKey = attributeData.isKey;
        return { ...node, data: newData };
      }
      return node;
    });
    set({ nodes: nodes, hasUnsavedChanges: true });
  },

  removeEntityAttribute: (entityId, attributeId) => {
    const entity = get().nodes.find(n => n.id === entityId);
    if (!entity) return;
    set({
      nodes: get().nodes.filter(n => n.id !== attributeId).map(n => n.id === entityId ? { ...n, data: { ...n.data, attributes: n.data.attributes.filter(a => a.id !== attributeId) } } : n),
      edges: get().edges.filter(e => e.source !== attributeId && e.target !== attributeId),
      hasUnsavedChanges: true
    });
  },

  // --- RELATIONSHIP CONNECTIONS ---
  connectEntityToRelationship: (relationshipId, entityId) => {
    const relNode = get().nodes.find(n => n.id === relationshipId);
    if (!relNode || relNode.data.entityConnections?.includes(entityId)) return;
    const newEdgeId = `edge-${entityId}-${relationshipId}-${Date.now()}`;
    const newEdge = { id: newEdgeId, source: entityId, sourceHandle: 'handle-relations-right', target: relationshipId, type: 'erdEdge', label: 'N', data: { edgeType: 'relationship', sourceCardinality: 'MANY', targetCardinality: 'ONE', role: null } };
    set({
      nodes: get().nodes.map(n => n.id === relationshipId ? { ...n, data: { ...n.data, entityConnections: [...(n.data.entityConnections || []), entityId] } } : n),
      edges: [...get().edges, newEdge],
      hasUnsavedChanges: true
    });
  },

  disconnectEntityFromRelationship: (relationshipId, entityId) => {
    const relNode = get().nodes.find(n => n.id === relationshipId);
    if (!relNode) return;
    set({
      nodes: get().nodes.map(n => n.id === relationshipId ? { ...n, data: { ...n.data, entityConnections: (n.data.entityConnections || []).filter(id => id !== entityId) } } : n),
      edges: get().edges.filter(e => !((e.source === entityId && e.target === relationshipId) || (e.source === relationshipId && e.target === entityId))),
      hasUnsavedChanges: true
    });
  },

  // --- RELATIONSHIP ATTRIBUTE ACTIONS ---
  connectAttributeToRelationship: (relationshipId, attributeId) => {
    const rel = get().nodes.find(n => n.id === relationshipId);
    const attribute = get().nodes.find(n => n.id === attributeId);
    if (!rel || !attribute) return;
    if (rel.data.attributes?.some(attr => attr.id === attributeId)) return;
    const newEdge = { id: `edge-${relationshipId}-${attributeId}`, source: relationshipId, target: attributeId, type: 'erdEdge', data: { edgeType: 'attribute' } };
    const updatedAttributes = [...(rel.data.attributes || []), { id: attributeId, name: attribute.data.label, isKey: false }];
    set({ nodes: get().nodes.map(n => n.id === relationshipId ? { ...n, data: { ...n.data, attributes: updatedAttributes } } : n), edges: addEdge(newEdge, get().edges), hasUnsavedChanges: true });
  },

  disconnectAttributeFromRelationship: (relationshipId, attributeId) => {
    const rel = get().nodes.find(n => n.id === relationshipId);
    if (!rel) return;
    set({
      nodes: get().nodes.map(n => n.id === relationshipId ? { ...n, data: { ...n.data, attributes: n.data.attributes.filter(attr => attr.id !== attributeId) } } : n),
      edges: get().edges.filter(edge => !((edge.source === relationshipId && edge.target === attributeId) || (edge.source === attributeId && edge.target === relationshipId))),
      hasUnsavedChanges: true
    });
  },

  addAttributeToRelationship: (relationshipId, attributeData) => {
    const relNode = get().nodes.find(n => n.id === relationshipId);
    if (!relNode) return;
    const attributeId = `attr-rel-${Date.now()}`;
    const existingAttributes = relNode.data.attributes || [];
    const offsetX = (existingAttributes.length % 2 === 0 ? 1 : -1) * 120;
    const offsetY = (Math.floor(existingAttributes.length / 2) + 1) * 120;
    const newAttributeNode = { id: attributeId, type: 'attributeNode', position: { x: relNode.position.x + offsetX, y: relNode.position.y + offsetY }, data: { label: attributeData.name || 'Rel_Attribute', isKey: false, parentId: relationshipId } };
    const newEdge = { id: `edge-${relationshipId}-${attributeId}`, source: relationshipId, target: attributeId, type: 'erdEdge', data: { edgeType: 'attribute' } };
    const updatedAttributes = [...existingAttributes, { id: attributeId, name: attributeData.name || 'Rel_Attribute' }];
    set({
      nodes: [...get().nodes.map(n => n.id === relationshipId ? { ...n, data: { ...n.data, attributes: updatedAttributes } } : n), newAttributeNode],
      edges: [...get().edges, newEdge],
      hasUnsavedChanges: true
    });
  },

  updateRelationshipAttribute: (relationshipId, attributeId, attributeData) => {
    const rel = get().nodes.find(n => n.id === relationshipId);
    if (!rel) return;
    const updatedAttributes = rel.data.attributes.map(attr => attr.id === attributeId ? { ...attr, ...attributeData } : attr);
    const nodes = get().nodes.map(node => {
      if (node.id === relationshipId) return { ...node, data: { ...node.data, attributes: updatedAttributes } };
      if (node.id === attributeId && attributeData.name) return { ...node, data: { ...node.data, label: attributeData.name } };
      return node;
    });
    set({ nodes: nodes, hasUnsavedChanges: true });
  },

  removeRelationshipAttribute: (relationshipId, attributeId) => {
    const relNode = get().nodes.find(n => n.id === relationshipId);
    if (!relNode) return;
    set({
      nodes: get().nodes.filter(n => n.id !== attributeId).map(n => n.id === relationshipId ? { ...n, data: { ...n.data, attributes: n.data.attributes.filter(a => a.id !== attributeId) } } : n),
      edges: get().edges.filter(e => e.source !== attributeId && e.target !== attributeId),
      hasUnsavedChanges: true
    });
  },

  getEntityNodes: () => { return get().nodes.filter(node => node.type === 'entityNode'); },
  
  updateEdgeCardinality: (edgeId, cardinalityValue) => {
    const mapCardinality = (value) => { switch (value) { case '1': return 'ONE'; case 'N': case 'M': return 'MANY'; default: return 'ONE'; } };
    set({ edges: get().edges.map(e => { if (e.id === edgeId) { return { ...e, label: cardinalityValue, data: { ...e.data, sourceCardinality: mapCardinality(cardinalityValue) } }; } return e; }), hasUnsavedChanges: true });
  },

  // --- FOREIGN KEY LOGIC ---
  
  /**
   * Add a Foreign Key attribute to an entity
   * @param {string} entityId - The entity to add FK to
   * @param {object} fkData - { name, referencedEntity, referencedAttribute }
   */
  addForeignKeyToEntity: (entityId, fkData) => {
    const entity = get().nodes.find(n => n.id === entityId);
    if (!entity) return;
    
    const fkId = `fk-${Date.now()}`;
    const fkAttribute = {
      id: fkId,
      name: fkData.name || `${fkData.referencedEntity}_id`,
      isKey: false,
      isForeignKey: true,
      referencedEntity: fkData.referencedEntity,
      referencedAttribute: fkData.referencedAttribute || 'id'
    };
    
    // Check if FK already exists
    const existingFk = entity.data.attributes?.find(attr => 
      attr.isForeignKey && attr.referencedEntity === fkData.referencedEntity
    );
    if (existingFk) return; // FK already exists
    
    const updatedAttributes = [...(entity.data.attributes || []), fkAttribute];
    
    set({
      nodes: get().nodes.map(n => n.id === entityId 
        ? { ...n, data: { ...n.data, attributes: updatedAttributes } } 
        : n),
      hasUnsavedChanges: true
    });
  },

  /**
   * Remove a Foreign Key from an entity
   * @param {string} entityId - The entity to remove FK from
   * @param {string} referencedEntity - The entity that was referenced
   */
  removeForeignKeyFromEntity: (entityId, referencedEntity) => {
    const entity = get().nodes.find(n => n.id === entityId);
    if (!entity) return;
    
    const updatedAttributes = (entity.data.attributes || []).filter(attr => 
      !(attr.isForeignKey && attr.referencedEntity === referencedEntity)
    );
    
    set({
      nodes: get().nodes.map(n => n.id === entityId 
        ? { ...n, data: { ...n.data, attributes: updatedAttributes } } 
        : n),
      hasUnsavedChanges: true
    });
  },

  /**
   * Update relationship type and handle FK migration
   * @param {string} relationshipId - The relationship node ID
   * @param {string} newType - '1:1', '1:N', 'N:1', 'M:N'
   */
  updateRelationshipType: (relationshipId, newType) => {
    const relNode = get().nodes.find(n => n.id === relationshipId);
    if (!relNode) return;
    
    const entityConnections = relNode.data.entityConnections || [];
    if (entityConnections.length !== 2) {
      // Just update the type without FK logic if not exactly 2 entities
      set({
        nodes: get().nodes.map(n => n.id === relationshipId 
          ? { ...n, data: { ...n.data, relationshipType: newType } } 
          : n),
        hasUnsavedChanges: true
      });
      return;
    }
    
    const [entity1Id, entity2Id] = entityConnections;
    const entity1 = get().nodes.find(n => n.id === entity1Id);
    const entity2 = get().nodes.find(n => n.id === entity2Id);
    
    if (!entity1 || !entity2) return;
    
    const entity1Name = entity1.data.label;
    const entity2Name = entity2.data.label;
    
    let updatedNodes = [...get().nodes];
    
    // First, remove existing FKs from this relationship
    updatedNodes = updatedNodes.map(n => {
      if (n.id === entity1Id || n.id === entity2Id) {
        const attrs = (n.data.attributes || []).filter(attr => 
          !(attr.isForeignKey && (attr.referencedEntity === entity1Name || attr.referencedEntity === entity2Name))
        );
        return { ...n, data: { ...n.data, attributes: attrs } };
      }
      return n;
    });
    
    // Now add FKs based on new relationship type
    // FK goes to the "Many" side, or to entity2 for 1:1
    switch (newType) {
      case '1:1':
        // FK goes to entity2 (second entity)
        updatedNodes = updatedNodes.map(n => {
          if (n.id === entity2Id) {
            const fkAttr = {
              id: `fk-${Date.now()}`,
              name: `${entity1Name.toLowerCase()}_id`,
              isKey: false,
              isForeignKey: true,
              referencedEntity: entity1Name
            };
            return { ...n, data: { ...n.data, attributes: [...(n.data.attributes || []), fkAttr] } };
          }
          return n;
        });
        break;
        
      case '1:N':
        // FK goes to entity2 (the "N" / Many side)
        updatedNodes = updatedNodes.map(n => {
          if (n.id === entity2Id) {
            const fkAttr = {
              id: `fk-${Date.now()}`,
              name: `${entity1Name.toLowerCase()}_id`,
              isKey: false,
              isForeignKey: true,
              referencedEntity: entity1Name
            };
            return { ...n, data: { ...n.data, attributes: [...(n.data.attributes || []), fkAttr] } };
          }
          return n;
        });
        break;
        
      case 'N:1':
        // FK goes to entity1 (the "N" / Many side)
        updatedNodes = updatedNodes.map(n => {
          if (n.id === entity1Id) {
            const fkAttr = {
              id: `fk-${Date.now()}-2`,
              name: `${entity2Name.toLowerCase()}_id`,
              isKey: false,
              isForeignKey: true,
              referencedEntity: entity2Name
            };
            return { ...n, data: { ...n.data, attributes: [...(n.data.attributes || []), fkAttr] } };
          }
          return n;
        });
        break;
        
      case 'M:N':
        // No FK injection - M:N uses a junction table (the relationship itself holds attributes)
        // Optionally, we could create a junction entity here
        break;
    }
    
    // Update the relationship type
    updatedNodes = updatedNodes.map(n => n.id === relationshipId 
      ? { ...n, data: { ...n.data, relationshipType: newType } } 
      : n);
    
    set({ nodes: updatedNodes, hasUnsavedChanges: true });
  }
}));

export default useFlowStore;